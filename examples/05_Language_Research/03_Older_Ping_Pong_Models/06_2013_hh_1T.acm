
#semantics "2012 Reference"

// Model   :  2012_hh_1T.acm, First Tournament (3D Ping Pong)
// Acumen  :  http://www.acumen-language.org/2013/01/a-preview-of-acumen13.html
// Author  :  Yingfu Zeng, Walid Taha, and others (see below)
// Date    :  2012/02/11
// Revision:  2013/02/06 New syntax for assignments (= and :=)
// Ideas   :  Bat has no mass.  Focus is on: Impact,  
//            problem decomposition, and systems modeling
// License:   BSD, GPL(V2), or other by agreement with Walid Taha

class Ball ()
 private
  mode := "Fly";
  k_z  := [1,1,-0.99];       // Coefficient of restitution
  k2   := 1/6;               // Coefficient of the air resistance
  p    := [0,0,0.5];         // Position of the ball
  p'   := [5,1,-3];
  p''  := [0,0,0];
  _3D  := ["Sphere",[0,0,0.5],0.03,[1,1,1],[0,0,0]];
 end
 _3D = ["Sphere",p,0.03,[1,1,1],[0,0,0]];
 // If mode is not valid then make mode "Panic!"
 if mode <> "Fly"&& mode <> "Bounce"&& mode <> "Freeze"
   mode := "Panic!";
 end;
 // Behavior of ball in different modes
 switch mode
  case "Fly"
   if dot(p,[0,0,1]) < 0&& dot(p',[0,0,1])< 0
    mode := "Bounce";
   else // Acceleration is air resistance and gravity
    p'' = -k2 * norm(p') * p' + [0,0,-9.8];
   end;
  case "Bounce"
    p'   :=  p' .* k_z; // Bounce losing k_z energy
    mode := "Fly";
  case "Freeze"       // The ball becomes red and freezes for a bit
    p'  = [0,0,0]; p'' = [0,0,0];
    _3D = ["Sphere",p,0.03,[1,0,0],[0,0,0]];
  case "Panic!"
  end
end


class BatActuator(p1)
 private
  p       := p1;
  p'      := [0,0,0];
  angle   := [0,0,0];
  energy  := 0;
  energy' := 0;
 end
  if norm(p') > 5 // “Saturate” speeds over 5
   p' := p'/norm(p') * 5 ;
  end;
  energy' = norm(p'); // Simplistic model of power consumed
end


class Bat(n,p1)
 private
  p     := p1;
  p'    := [0,0,0];
  angle := [0,0,0.1];
  displayAngle := [0,0,0];
  mode  := "Run";
  _3D   := ["Cylinder",p1,[0.15,0.05],[0.1,0.1,0.1],[0,0,0.5]];
 end
 switch mode
   case "Run"
     if n == 2
       displayAngle  
       = [0,dot(angle,[0,0,1])*(3.14/2)/norm(angle),
            dot(angle,[0,1,0])*(3.14/2)/norm(angle)]+[0,0,3.14/2];
       _3D = ["Cylinder",p+[0.05,0,0],[0.15,0.05],
                [0.1,0.1,0.1],displayAngle];
     else
       displayAngle 
       = [dot(angle,[0,0,1])*(3.14/2),0,
            dot(angle,[0,1,0])*(3.14/2)]+[0,0,3.14/2];
       _3D = ["Cylinder",p+[-0.05,0,0],[0.15,0.05],
                [1,0.1,0.1],-1 * displayAngle];
     end;
   case "Rest"
       p' = [0,0,0]; // Set speed to 0 in “Rest” mode
       _3D = ["Box",p+[-0.05,0,0],[0.3,0.3,0.3],
                [1,1,0.1],-1 * displayAngle];
   end
 end




/*
 Position and velocity of ball(ballp,ballv) always provide estimate;
 Once player decides to hit the ball, change the hit variable to
 true, the Game class will notice and calculate the output velocity 
 of the ball.
*/


/* The players:
   Reff:  Player
   2012:  Kong, Pisces, PingPing, WiffWaff, ParadoX, XPTO, Virtue
   2013:  Tornado, Terminator, Transporter, Torpedo
*/


class Torpedo(n)
/* The Player can be only used as player one                 */
/* Main changes to the default player:                                */
/* - Player does not return to start position to save energy        */
/* - Improved hitting the ball                                        */


/* Won against default player as well WiffWaff                */


private
mode := "Wait";                 // Initial mode is to “Wait”
bounced := false;                 // Has the ball bounced?
serve := false;                 // Your turn to serve? (set by Parent)
hit := false;                         // Set this to true to hit the ball
count := 0;                         // Bounce count
ballv := [0,0,0];                 // Ball velocity (set by Parent)
ballp := [0,0,0];                 // Ball position (set by Parent)
batp := [1.6,0,0.2];                 // Bat position
v := [0,0,0];                         // Bat velocity
batAngle := [0,0,0.1];                 // Normal vector of the bat's plane
batAngle' := [0,0,0];


// Player(1) startPoint is [-1.6,0,0.2] and
// Player(2) startPoint is [1.6,0,0.2]
startPoint := [1.6*(-1)^n,0,0.2];
t := 0;
t' := 1;
end
if mode <> "Wait"&& mode <> "Prepare"&& mode <> "Hit"
end;
t' = 1;                                 // Rate for local timer


switch mode


case "Wait"                         // While waiting, bat is not moving
count := 0;
if n == 1                         // Done differently depending on player
v = batp+ [0,0,0]-batp;                //startPoint + [0,0,0]-batp;


end;
batAngle' = [0,0,0] - batAngle;         // Readjust bat angle
hit := false;
if serve == true                         // Wait until Parent says serve
mode := "Prepare";
bounced := false;
else
mode := "Wait";
// Status = [1,0,0];
end;
case "Prepare"                         // Prepare to hit the ball


if bounced == true                         // Once ball bounces, move towards it
v = (ballp-batp).*[0,20,0] + (ballp-batp).*[0,0,25] +                                    
      (ballp+[0.12*(-1)^n,0,0]-batp).*[25,0,0];
if norm(batp - ballp)<0.15        //&& abs(dot(ballp,[1,0,0])) >=
//abs(dot(startPoint,[1,0,0]))
count := count+1;
mode := "Hit";
end;
end;
// When the ball has bounced and it is at the highest position
if count > 0&& dot(ballv,[0,0,1]) < 0.1&& bounced == true
mode := "Hit";                         // Means this player has decided to hit the ball
end;


// Bouncing condition
if dot(ballp,[0,0,1]) < 0&& bounced == false
bounced := true;
end;


// Go back to waiting when it is no longer your serve
if(serve <> true)
mode := "Wait";
end;
case "Hit"                                         // This player’s hitting strategy


if(dot(ballv,[0,1,0]) < 0.1)                        //Hit if the ball comes from the left side
v := [1,1,0.2];
batAngle := [-1,-0.162,-0.29];
else                                                //Hit if the ball comes from the right side
v := [1,0,1.85];
batAngle := [-1,0.202,-0.29];
end;
serve := false;
hit := true;
mode := "Wait";
end
end


class Transporter(n)
 private
 mode      := "Wait";   // Initial mode is to “Wait”
 bounced   := false;    // Has the ball bounced?
 serve := false;        // Your turn to serve?  (set by Parent)
 hit   := false;        // Set this to true to hit the ball
 count := 0;            // Bounce count
 ballv := [0,0,0];      // Ball velocity (set by Parent)
 ballp := [0,0,0];      // Ball position (set by Parent)
 batp  := [1.6,0,0.2];  // Bat  position
 v     := [0,0,0];      // Bat velocity
 batAngle   := [0,0,0.1];  // Normal vector of the bat's plane
 batAngle'  := [0,0,0];
 // Player(1) startPoint is [-1.6,0,0.2] and
 // Player(2) startPoint is [1.6,0,0.2]
 startPoint := [1.6*(-1)^n,0,0.2];
 t   := 0;
 t'  := 1;
 ballvHcos := 0; //The value of cos that is the angle between ball velocity and horizontal axis(x)
 ballvVcos := 0; //The value of cos that is the angle between ball velocity and vertical axis(y)
 ballpEA := 0; //The angle between ball velocity and edge
 btoE := [0,0,0];//The distance between ball and edge
 esDistance := 0;//The initial distance in estimation
 esBallV := [0,0,0];//The initial velocity of ball in estimation
 esBatV := [0,0,0];//The initial velocity of bat in estimation
 esHeight := 0.5;//The initial height
 g := 9.8;
 coe:=8;
end
if mode <> "Wait"&& mode <> "Prepare"&& mode <> "Hit"
  mode := "Panic!";
end;
t'  = 1;   // Rate for local timer
switch mode
 case "Wait" // When waiting, moving the bat to start point
  count := 0;
  if n == 1  // Done differently depending on player
    v         = startPoint - batp;
  else
    v         = startPoint + [0,0.75,0] - batp;
  end;
  batAngle' = [0,0,0] - batAngle; // Readjust bat angle
  hit    := false;
  if serve == true // Wait until Parent says serve
   mode    := "Prepare";
   bounced := false;
  else
   mode := "Wait";
  end;
 case "Prepare"          // Prepare to hit the ball
  if bounced == true     // Once ball bounces, move towards it
    v = (ballp-batp).*[0,20,0] + (ballp-batp).*[0,0,25] +
          (ballp+[0.12*(-1)^n,0,0]-batp).*[25,0,0];
    if norm(batp - ballp)<0.15&& abs(dot(ballp,[1,0,0])) >=
                              abs(dot(startPoint,[1,0,0]))
     count := count+1;
     mode  := "Hit";
    end;
  end;
  // When the ball has bounced and it is at the highest position
  if count > 0&& dot(ballv,[0,0,1]) < 0.1&& bounced == true
   mode := "Hit"; // Means this play has decided to hit the ball
  end;
  // Bouncing condition
  if dot(ballp,[0,0,1]) < 0&& bounced == false
   bounced := true;
  end;
  // Go back to waiting when it is no longer your serve
  if(serve <> true)
    mode := "Wait";
  end;
case "Hit"           // This player’s hitting strategy
  if n == 2
    ballvHcos := dot(ballv,[1,0,0])/norm(ballv)*norm([1,0,0]);
    ballvVcos := dot(ballv,[0,1,0])/norm(ballv)*norm([0,1,0]);
  if(ballvHcos >= 0.5&& ballvHcos <= 1)
  if(ballvVcos > 0)
    btoE = ballp-[-1.6,-0.8,0];
    ballpEA = acos(dot(btoE,[-1,0,0])/norm(btoE)*norm([-1,0,0]));
  else
  if(ballvVcos <= 0)
     btoE = ballp-[1.6,0.8,0];
     ballpEA = acos(dot(btoE,[-1,0,0])/norm(btoE)*norm([-1,0,0]));
   end;
 end;
else
 if(ballvHcos < 0.5)
     btoE = ballp-[-1.6,0,0];
     ballpEA =  acos(dot(btoE,[-1,0,0])/norm(btoE)*norm([-1,0,0]));
 end;
end;
 if(dot(batp,[0,1,0])<0)
    ballpEA = -ballpEA;
end;
  esDistance = norm(btoE);
  esBallV = [sqrt((esDistance^2)*g/2*esHeight)*cos(ballpEA),sqrt((esDistance^2)*g/2*esHeight)*sin(ballpEA),sqrt(2*g*esHeight)];
  v:= 3*(esBallV - ballv)/coe;
  batAngle:= [0.97,ballpEA*0.06,-(esDistance/sqrt(4*(esHeight^2)+esDistance^2))/6];
else
  ballvHcos := dot(ballv,[-1,0,0])/norm(ballv)*norm([-1,0,0]);
  ballvVcos := dot(ballv,[0,1,0])/norm(ballv)*norm([0,1,0]);
 if(ballvHcos >= 0.5&& ballvHcos <= 1)
 if(ballvVcos > 0)
   btoE := ballp-[1.6,0.8,0];
   ballpEA := acos(dot(btoE,[1,0,0])/norm(btoE)*norm([1,0,0]));    
 else
   if(ballvVcos <= 0)
     btoE := ballp-[-1.6,-0.8,0];      
     ballpEA := acos(dot(btoE,[1,0,0])/norm(btoE)*norm([1,0,0]));
   end;
 end;
else
 if(ballvHcos < 0.5)
   btoE := ballp-[1.6,0,0];
   ballpEA :=  acos(dot(btoE,[1,0,0])/norm(btoE)*norm([1,0,0]));
 end;
end;
if(dot(batp,[0,1,0])<0)
 ballpEA := -ballpEA;
end;
 esDistance := norm(btoE);
 esBallV := [sqrt((esDistance^2)*g/2*esHeight)*cos(ballpEA),sqrt((esDistance^2)*g/2*esHeight)*sin(ballpEA),sqrt(2*g*esHeight)];
 v:= (ballv-esBallV)*3.0;
 batAngle = [-0.91,ballpEA*0.06,-(esDistance/sqrt(4*(esHeight^2)+esDistance^2))/3];  
  end;
 serve  := false;
 hit    := true;
 mode   := "Wait";
case "Panic!"
end
end


class Terminator(n)
// ----------------------------------------------------------------------
// Project Terminator: the ball breaking robot
// ======================================================================
// Date    : 2013/02/12
// Authors : Jonas Jonson and Alexey Taktarov
// ----------------------------------------------------------------------
 private
   mode       := "Wait";       // Initial mode is to “Wait”
   bounced    := false;        // Has the ball bounced?
   serve      := false;        // Your turn to serve?  (set by Parent)
   hit        := false;        // Set this to true to hit the ball
   count      := 0;            // Bounce count
   ballv      := [0,0,0];      // Ball velocity (set by Parent)
   ballp      := [0,0,0];      // Ball position (set by Parent)
   batp       := [1.6,0,0.2];  // Bat  position
   v          := [0,0,0];      // Bat velocity
   batAngle   := [0,0,0.1];    // Normal vector of the bat's plane
   batAngle'  := [0,0,0];
 
   // Player(1) startPoint is [-1.6,0,0.2] and
   // Player(2) startPoint is [1.6,0,0.2]
   startPoint := [1.6*(-1)^n,0,0.2];
   
   // These coefficients are needed for prediction of ball movement
   // Coefficient of restitution
   k_z := [1.0, 1.0, -0.99];
   // Coeffiecent of air resistance
   k_a := -1/6;


   // Ball acceleration (predicted)
   a   := [0.0, 0.0, -9.8];


   // First prediction poit: time, position, speed
   // When ball hits the table
   t1  := 0.0;
   p1  := [0, 0, 0];
   pv1 := [0, 0, 0];


   // Second prediction point: time, position, speed
   // The maximum point of the second parabola
   t2  := 0.0;
   p2  := [0, 0, 0];
   pv2 := [0, 0, 0];


   // Local timer
   t          := 0.0;
   t'         := 1.0;    


   // Delay
   reaction   := 0.3;


   // Prediction pointers (for debugging)
   _3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],
           ["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];
 end
   t' = 1;
   
 switch mode
   
   case "Wait"
     // Reset all variables
     hit     := false;
     bounced := false;
     
     v = [0.0,0.0,0.0];
     t = 0;
     
     if serve == true
       mode := "Predict";
     end;


   case "Predict"
     // Bouncing condition
     if dot(ballp,[0,0,1]) < 0&& bounced == false
       bounced := true;
     end;


     if bounced == true
       p1  = ballp;
       pv1 = ballv;
       t1  = 0;
     else
       // Calculating first prediction point
       // Linearized air resistance
       a = [0, 0, -9.8] + k_a * norm(ballv) * ballv;
      
       t1 = (1/dot(a, [0, 0, 1])) *        // 1/a
              (-dot(ballv, [0, 0, 1])      // -v0
              - 1*sqrt(dot(ballv, [0, 0, 1])*dot(ballv, [0, 0, 1])
              - 2*dot(a, [0,0,1])*dot(ballp, [0, 0, 1])));
              
       p1  =  ballp + ballv .* [t1, t1, t1] + 0.5 * a .* [t1, t1, t1] .* [t1, t1, t1];
       pv1 =  (ballv + a .* [t1, t1, t1]) .* k_z;


       // Check if ball is going out of bounds
       // We can predict this before it actually happens
       // This actually can decrease power consuption in some cases.
       if t > 0.2*t1
         if dot(p1, [1, 0, 0])*(-1)^n > 1.5 ||
            dot(p1, [1, 0, 0])*(-1)^n < 0   ||
            abs(dot(p1, [0, 1, 0])) > 0.75
           serve := false;
           mode := "Wait";
         end;
       end;
     end;
       // Calculating second prediction point
       // Linearized air resistance
       a = [0, 0, -9.8] + k_a * norm(pv1) * pv1;
       
       t2 = -dot(pv1, [0,0,1]) / dot([0,0,1], a);
       p2 = p1 + pv1 .* [t2, t2, t2] + 0.5 * a .* [t2, t2, t2] .* [t2, t2, t2];
       pv2 = p1 + a .* [t2, t2, t2];


       if t > reaction*t1
           // Moving our bat to second prediction point
           v = 1.0 * (p2 - batp) / (t1 + t2);
       end;
       
       _3D := [["Sphere",p1,0.02,[200,0,0],[0,0,0]],
               ["Sphere",p2,0.02,[0,0,200],[0,0,0]]];


       // Is it time to hit the ball?
       if norm(batp - ballp) < 0.15   
         mode  := "Hit";
       end;


        
  case "Hit"     
    // TODO: correct this formula!
    v      := 1.8*((1 / norm(ballv)) * ballv  .* [-1, -1, 0] +[0,0,0.3]);


    // Bat angle is always towards bat's speed
    batAngle := (1 / norm(v)) * v .* [-1,-1,-1];
    
    serve  := false;
    hit    := true;
    mode   := "Wait";
    
   case "Panic!"
 end
end


class Tornado(n)
/* This is Tornado.
As Player 1, it beats the default player 3:1, which then runs out of energy. It looks ugly. :-)
As Player 2, there is no simulation.
It tracks the ball at the same speed as the ball itself.
The decision in which direction the ball is hit, is based on 2 factors: 1) On which side of the table we are? And 2) the speed of the ball in z direction.
If the we are on the left side the bat is rotated to the right to send the ball to the middle of the table, and vice versa.
If the ball is going upwards, it is hit with no angle around Y axis (not facing up) thus not gaining any more speed in Z direction. But, if the ball has a negative speed in Z direction, it will be hit with the bat facing up.
*/


private
  mode      := "Wait";
  ballp     := [0, 0, 0];
  ballv     := [0, 0, 0];
  batp      := [0, 0, 0];
  v         := [0, 0, 0];
  batAngle  := [0, 0, 0];
  batAngle' := [0, 0, 0];
  bounced   := false;
  serve     := false;
  hit       := false;


  _3D := [];
  pos := [0, 0, 0];
  sp  := 0;


end
  switch mode
    case "Wait"
      _3D = ["Sphere", [0,0,1], 0.1, [1,0,0], [0,0,0]];
      bounced := false; hit := false; v = [0, 0, 0];
      if(serve == true) mode := "Prepare1" end;


    case "Prepare1"
      _3D = ["Sphere", [0,0,1], 0.1, [1,1,0], [0,0,0]];
      if(dot(ballp,[0,0,1]) <= 0) bounced := true end;
      if(serve   == false) mode := "Wait" end;
      if(bounced == true)  mode := "Prepare2" end;


      /* follow the ball */
      if(dot([0,1,0],ballp) < 0) pos = ballp + [0,-0.25,0];
      else                       pos = ballp + [0,0.25,0];
      end;
      sp = abs(dot([1,1,0],ballv));
      v = [0,sp,sp] .* (pos - batp);




    case "Prepare2"
      _3D = ["Sphere", [0,0,1], 0.1, [0,1,0], [0,0,0]];
      if(norm(batp - ballp) < 0.15) mode := "Hit" end;


      /* follow the ball */
      if(dot([0,1,0],ballp) < 0) pos = ballp + [0,-0.25,0];
      else                       pos = ballp + [0,0.25,0];
      end;
      sp = abs(dot([1,1,0],ballv));
      v = [0,sp,sp] .* (pos - batp);






    case "Hit"
      _3D = ["Sphere", [0,0,1], 0.1, [0,0,1], [0,0,0]];


      /* send the ball to the left or right */
      if(dot([0,1,0],ballp) < 0) batAngle := [1, 0.3, 0.5];
      else                       batAngle := [1, -0.3, 0.5];
      end;


      /* send the ball up or straight */
      if(dot([0,0,01],ballv) < 0) batAngle := batAngle + [0, 0, 0.3];
      else                        batAngle := batAngle + [0, 0, 0];
      end;


      v        := [1, 0, 0];




      serve := false;
      hit   := true;
      mode  := "Wait";


  end
end




class Player(n)
 private
  mode      := "Wait";   // Initial mode is to “Wait”
  bounced   := false;    // Has the ball bounced?
  serve := false;        // Your turn to serve?  (set by Parent)
  hit   := false;        // Set this to true to hit the ball
  count := 0;            // Bounce count
  ballv := [0,0,0];      // Ball velocity (set by Parent)
  ballp := [0,0,0];      // Ball position (set by Parent)
  batp  := [1.6,0,0.2];  // Bat  position
  v     := [0,0,0];      // Bat velocity
  batAngle   := [0,0,0.1];  // Normal vector of the bat's plane
  batAngle'  := [0,0,0];
  // Player(1) startPoint is [-1.6,0,0.2] and
  // Player(2) startPoint is [1.6,0,0.2]
  startPoint := [1.6*(-1)^n,0,0.2];
  t   := 0;
  t'  := 1;
 end
 if mode <> "Wait"&& mode <> "Prepare"&& mode <> "Hit"
   mode := "Panic!";
 end;
 t'  = 1;   // Rate for local timer
 switch mode
  case "Wait" // When waiting, moving the bat to start point
   count := 0;
   if n == 1  // Done differently depending on player
     v         = startPoint - batp;
   else
     v         = startPoint + [0,0.75,0] - batp;
   end;
   batAngle' = [0,0,0] - batAngle; // Readjust bat angle
   hit    := false;
   if serve == true // Wait until Parent says serve
    mode    := "Prepare";
    bounced := false;
   else
    mode := "Wait";
   end;
  case "Prepare"          // Prepare to hit the ball
   if bounced == true     // Once ball bounces, move towards it
     v = (ballp-batp).*[0,20,0] + (ballp-batp).*[0,0,25] +
           (ballp+[0.12*(-1)^n,0,0]-batp).*[25,0,0];
     if norm(batp - ballp)<0.15&& abs(dot(ballp,[1,0,0])) >=
                               abs(dot(startPoint,[1,0,0]))
      count := count+1;
      mode  := "Hit";
     end;
   end;
   // When the ball has bounced and it is at the highest position
   if count > 0&& dot(ballv,[0,0,1]) < 0.1&& bounced == true
    mode := "Hit"; // Means this play has decided to hit the ball
   end;
   // Bouncing condition
   if dot(ballp,[0,0,1]) < 0&& bounced == false
    bounced := true;
   end;
   // Go back to waiting when it is no longer your serve
   if(serve <> true)
     mode := "Wait";
   end;
 case "Hit"           // This player’s hitting strategy
  if n == 2
   if(t<1||t>5)       // you may want to check the formulas
                      // in the BallActuator() class (Yingfu)
    v        := [-1.38,0.40,1.2];
    batAngle := [0.9471,0.25,-0.2];
   else
    if t > 4&& t < 5
     v        := [-0.88,-0.5,0.2];
     batAngle := [0.9471,0.25,-0.2];
 else
     v        := [-1.7,-0.2,3.86];
     batAngle := [0.96,-0.1,-0.2258];
 end;
   end;
  else
   if(dot(ballv,[0,1,0]) < 0)
    v        := [0.1,-0.15,3.85];
    batAngle := [-0.938,-0.162,-0.29];
   else
    v        := [1,0,2.85];
    batAngle := [-0.938,0.202,-0.29];
    end;
   end;
  serve  := false;
  hit    := true;
  mode   := "Wait";
 case "Panic!"
 end
end


class Kong(n)
 private
  stl:=0;
  hs:="hitpos";
  mode          := "Wait";
  bounced   := false;           // Tell whether the ball bounced or not
  serve := false;               // The Game class will set serve flag to true
  hit   := false;               // when it's your turn
  count := 0;
  ballv := [0,0,0];
  ballp := [0,0,0];
  batp  := [1.6,0,0.2];
  v         := [0,0,0];             // Bat's speed
  batAngle   := [0,0,0.1];  // Normal vector of the bat's plane
  batAngle'  := [0,0,0];
  // Player(1) starts at [-1.6,0,0.2], Player(2) starts at [1.6,0,0.2]
  startPoint := [1.6*(-1)^n,0,0.2];
  t   := 0;
  t'  := 1;
 end
 if mode <> "Wait"&& mode <> "Prepare"&& mode <> "Hit"
   mode := "Panic!";
 end;
 t'  = 1;
 switch mode
  case "Wait"                   // While waiting, moving the bat to starting point
   count          := 0;
   if n == 1
         v             = startPoint-batp;
   else
         v             = startPoint + [0,0.75,0] - batp;
   end;
   batAngle' = [0,0,0]-batAngle;
   hit        := false;
   if serve == true
        mode        := "Prepare";
        bounced := false;
   else
        mode := "Wait";
   end;
  case "Prepare"                 // Prepare to hit the ball
   if bounced == true            // After the ball has bounced,
                                 // start moving the bat towards the ball
         v = (ballp-batp).*[0,20,0] + (ballp-batp).*[0,0,25] +
               (ballp+[0.12*(-1)^n,0,0]-batp).*[25,0,0];
         if norm(batp - ballp)<0.15&& abs(dot(ballp,[1,0,0])) >=
                                   abs(dot(startPoint,[1,0,0]))
          count := count+1;
          mode  := "Hit";
         end;
   end;
   // When the ball has bounced and it is at the highest position
   if count > 0&& dot(ballv,[0,0,1]) < 0.1&& bounced == true
        mode := "Hit";         // This player decide to hit.
   end;
   if dot(ballp,[0,0,1]) < 0&& bounced == false
        bounced := true;
   end;
   if(serve <> true)
         mode := "Wait";
   end;
 case "Hit"               // Decide how you want hit the ball,
  if n == 2
  if stl>30
        hs := "hitn";end;
 if dot(ballp,[0,1,0]) <= -0.30
 hs := "hitpos";end;
 if (dot(ballp,[0,1,0]) > -0.30)&& (dot(ballp,[0,1,0]) < 0.30)
 hs := "hitnear";end;
 if (dot(ballp,[0,1,0]) >= 0.30)
            hs := "hitneg";end;
   if (hs == "hitpos")
            v := [3.8,0.80,14.5];
            batAngle := [0.95,0.13,-0.3];end;
   if (hs == "hitneg")
             v := [3.8,-0.8,14.5];
             batAngle := [0.95,0.05,-0.32];end;
 if (hs == "hitnear")
            v := [3.5,-0.5*dot(ballv,[0,1,0]),15.0];
            batAngle := [0.95,-0.2,-0.28];end;
 if (hs == "hitn")
            v := [3.5,0.3,13.0];
            batAngle := [0.95,0.0,-0.28];end;
 stl:= stl+1;
   end;
  serve  := false;
  hit        := true;
  mode   := "Wait";
 case "Panic!"
 end
end






class Pisces(n)


 private  mode      := "Wait";
  bounced   := false;       // Tell whether the ball bounced or not
  serve := false;           // The Game class will set serve flag to true
  hit   := false;           // when it's your turn
  count := 0;
  ballv := [0,0,0];
  ballp := [0,0,0];
  batp  := [1.6,0,0.2];
  v     := [0,0,0];         // Bat's speed
  batAngle   := [0,0,0.1];  // Normal vector of the bat's plane
  batAngle'  := [0,0,0];
  // Player(1) starts at [-1.6,0,0.2], Player(2) starts at [1.6,0,0.2]
  startPoint := [1.6*(-1)^n,0,0.2];
  t   := 0;
  t'  := 1;
 end
 if mode <> "Wait"&& mode <> "Prepare"&& mode <> "Hit"
   mode := "Panic!";
 end;
 t'  = 1;
 switch mode
  case "Wait"               // While waiting, moving the bat to starting point
   count      := 0;
   if n == 1
     v         = startPoint-batp;
   else
     v         = startPoint + [0,0.75,0] - batp;
   end;
   batAngle' = [0,0,0]-batAngle;
   hit    := false;
   if serve == true
    mode    := "Prepare";
    bounced := false;
   else
    mode := "Wait";
   end;
  case "Prepare"             // Prepare to hit the ball
   if bounced == true        // After the ball has bounced,
                             // start moving the bat towards the ball
     v = (ballp-batp).*[0,20,0] + (ballp-batp).*[0,0,25] +
           (ballp+[0.12*(-1)^n,0,0]-batp).*[25,0,0];
     if norm(batp - ballp)<0.15&& abs(dot(ballp,[1,0,0])) >=
                               abs(dot(startPoint,[1,0,0]))
      count := count+1;
      mode  := "Hit";
     end;
   end;
   // When the ball has bounced and it is at the highest position
   if count > 0&& dot(ballv,[0,0,1]) < 0.1&& bounced == true
    mode := "Hit";     // This player decide to hit.
   end;
   if dot(ballp,[0,0,1]) < 0&& bounced == false
    bounced := true;
   end;
   if(serve <> true)
     mode := "Wait";
   end;
 case "Hit"           // Decide how you want hit the ball,




if n == 2
if(dot(ballv,[1,0,0]) >=3)
         // you may want to check the formulas
                      // in the BallActuator() class
    if(dot(ballp,[0,1,0])>0.1&& dot(ballp,[0,1,0])<=0.35)
      if(dot(ballp,[1,0,0])>0&& dot(ballp,[1,0,0])<=0.5)
       v    := [-0.38,0.40,1.2];
       batAngle := [0.9471,0.35,-0.2];
        
       else
        if(dot(ballp,[1,0,0])>0.5&& dot(ballp,[1,0,0])<=1)
       v        := [-0.38,0.40,1.2];
        batAngle := [0.9471,0.35,-0.5];
        else
         if(dot(ballp,[1,0,0])>1)
       v        := [-0.38,0.40,1.2];
       batAngle := [0.9471,0.2,-0.4];
       end;
       end;
       end;
       end;


    if(dot(ballp,[0,1,0])>0.35&& dot(ballp,[0,1,0])<=0.6)
      if(dot(ballp,[1,0,0])>0&& dot(ballp,[1,0,0])<=0.5)
       v    := [-0.38,0.40,1.2];
       batAngle := [0.9471,0.25,-0.2];
        
       else
        if(dot(ballp,[1,0,0])>0.5&& dot(ballp,[1,0,0])<=1)
       v        := [-0.38,0.40,1.2];
        batAngle := [0.9471,0.25,-0.3];
        else
         if(dot(ballp,[1,0,0])>1)
       v        := [-0.38,0.40,1.2];
       batAngle := [0.9471,0.0,-0.4];
       end;
       end;
       end;
       end;
    if(dot(ballp,[0,1,0])>0.6)
      if(dot(ballp,[1,0,0])>0&& dot(ballp,[1,0,0])<=0.5)
       v    := [-0.38,0.40,1.2];
       batAngle := [0.9471,0.25,-0.2];
        
       else
        if(dot(ballp,[1,0,0])>0.5&& dot(ballp,[1,0,0])<=1)
       v        := [-0.38,0.40,1.2];
        batAngle := [0.9471,0.3,-0.3];
        else
         if(dot(ballp,[1,0,0])>1)
       v        := [-0.38,0.40,1.2];
       batAngle := [0.9471,0.3,-0.4];
       end;
       end;
       end;
       end;




if(dot(ballp,[0,1,0])<-0.1&& dot(ballp,[0,1,0])>=-0.35)
      if(dot(ballp,[1,0,0])>0&& dot(ballp,[1,0,0])<=0.5)
       v        := [-0.7,-0.2,3.86];
     batAngle := [0.96,-0.5,-0.2258];        
       else
        if(dot(ballp,[1,0,0])>0.5&& dot(ballp,[1,0,0])<=1)
       v        := [-0.7,-0.2,3.86];
     batAngle := [0.96,-0.5,-0.2258];
else
         if(dot(ballp,[1,0,0])>1)
       v        := [-0.7,-0.2,3.86];
     batAngle := [0.96,-0.5,-0.4];
       end;
       end;
       end;
       end;
if(dot(ballp,[0,1,0])<-0.35&&dot(ballp,[0,1,0])>-0.6)
      if(dot(ballp,[1,0,0])>0&& dot(ballp,[1,0,0])<=0.5)
       v        := [-0.7,-0.2,3.86];
     batAngle := [0.96,-0.1,-0.2258];        
       else
        if(dot(ballp,[1,0,0])>0.5&& dot(ballp,[1,0,0])<=1)
       v        := [-0.7,-0.2,3.86];
     batAngle := [0.96,-0.1,-0.2258];
else
         if(dot(ballp,[1,0,0])>1)
       v        := [-0.7,-0.2,3.86];
     batAngle := [0.96,-0.1,-0.4];
       end;
       end;
       end;
       end;
if(dot(ballp,[0,1,0])<-0.6)
      if(dot(ballp,[1,0,0])>0&& dot(ballp,[1,0,0])<=0.5)
       v        := [-0.7,-0.2,3.86];
     batAngle := [0.96,-0.1,-0.2258];        
       else
        if(dot(ballp,[1,0,0])>0.5&& dot(ballp,[1,0,0])<=1)
       v        := [-0.7,-0.2,3.86];
     batAngle := [0.96,-0.3,-0.3];
else
         if(dot(ballp,[1,0,0])>1)
       v        := [-0.7,-0.2,3.86];
     batAngle := [0.96,-0.3,-0.4];
       end;
       end;
       end;
       end;


if(dot(ballp,[0,1,0])<=0.1&& dot(ballp,[0,1,0])>=-0.1)
      if(dot(ballp,[1,0,0])>0&& dot(ballp,[1,0,0])<=0.5)
       v    := [-0.38,0.40,1.2];
       batAngle := [0.9471,0,-0.6];
        
       else
        if(dot(ballp,[1,0,0])>0.5&& dot(ballp,[1,0,0])<=1)
       v        := [-0.38,0.40,1.2];
        batAngle := [0.9471,0,-0.5];
        else
         if(dot(ballp,[1,0,0])>1)
       v        := [-0.38,0.40,1.2];
       batAngle := [0.9471,0,-0.4];
       end;
       end;
       end;
       end;
end;




if(dot(ballv,[1,0,0]) >=1&& dot(ballv,[1,0,0]) <3)
    if(dot(ballp,[0,1,0])>0.1&& dot(ballp,[0,1,0])<=0.35)
      if(dot(ballp,[1,0,0])>0&& dot(ballp,[1,0,0])<=0.5)
       v    := [-1,0.40,1.2];
       batAngle := [0.9471,0.2,-0.5];
        
       else
        if(dot(ballp,[1,0,0])>0.5&& dot(ballp,[1,0,0])<=1)
       v        := [-1,0.40,1.2];
        batAngle := [0.9471,0.2,-0.4];
        else
         if(dot(ballp,[1,0,0])>1)
       v        := [-1,0.40,1.2];
       batAngle := [0.9471,0.2,-0.3];
       end;
       end;
       end;
       end;


    if(dot(ballp,[0,1,0])>0.35&& dot(ballp,[0,1,0])<=0.6)
      if(dot(ballp,[1,0,0])>0&& dot(ballp,[1,0,0])<=0.5)
       v    := [-1,0.40,1.2];
       batAngle := [0.9471,0.3,-0.5];
        
       else
        if(dot(ballp,[1,0,0])>0.5&& dot(ballp,[1,0,0])<=1)
       v        := [-1,0.40,1.2];
        batAngle := [0.9471,0.3,-0.4];
        else
         if(dot(ballp,[1,0,0])>1)
       v        := [-1,0.40,1.2];
       batAngle := [0.9471, 0.3,-0.3];
       end;
       end;
       end;
       end;
    if(dot(ballp,[0,1,0])>0.6)
      if(dot(ballp,[1,0,0])>0&& dot(ballp,[1,0,0])<=0.5)
       v    := [-1,0.40,1.2];
       batAngle := [0.9471,0.4,-0.5];
        
       else
        if(dot(ballp,[1,0,0])>0.5&& dot(ballp,[1,0,0])<=1)
       v        := [-1,0.40,1.2];
        batAngle := [0.9471,0.4,-0.4];
        else
         if(dot(ballp,[1,0,0])>1)
       v        := [-1,0.40,1.2];
       batAngle := [0.9471,0.4,-0.3];
       end;
       end;
       end;
       end;




if(dot(ballp,[0,1,0])<-0.1&& dot(ballp,[0,1,0])>=-0.35)
      if(dot(ballp,[1,0,0])>0&& dot(ballp,[1,0,0])<=0.5)
       v        := [-1,-0.2,3.86];
     batAngle := [0.96,-0.2,-0.5];        
       else
        if(dot(ballp,[1,0,0])>0.5&& dot(ballp,[1,0,0])<=1)
       v        := [-1,-0.2,3.86];
     batAngle := [0.96,-0.2,-0.4];
else
         if(dot(ballp,[1,0,0])>1)
       v        := [-1,-0.2,3.86];
     batAngle := [0.96,-0.2,-0.3];
       end;
       end;
       end;
       end;
if(dot(ballp,[0,1,0])<-0.35&&dot(ballp,[0,1,0])>-0.6)
      if(dot(ballp,[1,0,0])>0&& dot(ballp,[1,0,0])<=0.5)
       v        := [-1,-0.2,3.86];
     batAngle := [0.96,-0.3,-0.5];        
       else
        if(dot(ballp,[1,0,0])>0.5&& dot(ballp,[1,0,0])<=1)
       v        := [-1,-0.2,3.86];
     batAngle := [0.96,-0.3,-0.4];
else
         if(dot(ballp,[1,0,0])>1)
       v        := [-1,-0.2,3.86];
     batAngle := [0.96,-0.3,-0.3];
       end;
       end;
       end;
       end;
if(dot(ballp,[0,1,0])<-0.6)
      if(dot(ballp,[1,0,0])>0&& dot(ballp,[1,0,0])<=0.5)
       v        := [-1,-0.2,3.86];
     batAngle := [0.96,-0.4,-0.5];        
       else
        if(dot(ballp,[1,0,0])>0.5&& dot(ballp,[1,0,0])<=1)
       v        := [-1,-0.2,3.86];
     batAngle := [0.96,-0.4,-0.4];
else
         if(dot(ballp,[1,0,0])>1)
       v        := [-1,-0.2,3.86];
     batAngle := [0.96,-0.4,-0.3];
       end;
       end;
       end;
       end;


if(dot(ballp,[0,1,0])<=0.1&& dot(ballp,[0,1,0])>=-0.1)
      if(dot(ballp,[1,0,0])>0&& dot(ballp,[1,0,0])<=0.5)
       v    := [-1,0.40,1.2];
       batAngle := [0.9471,0,-0.5];
        
       else
        if(dot(ballp,[1,0,0])>0.5&& dot(ballp,[1,0,0])<=1)
       v        := [-1,0.40,1.2];
        batAngle := [0.9471,0,-0.4];
        else
         if(dot(ballp,[1,0,0])>1)
       v        := [-1,0.40,1.2];
       batAngle := [0.9471,0,-0.3];
       end;
       end;
       end;
       end;
end;
if(dot(ballv,[1,0,0]) <1)
    if(dot(ballp,[0,1,0])>0.1&& dot(ballp,[0,1,0])<=0.35)
      if(dot(ballp,[1,0,0])>0&& dot(ballp,[1,0,0])<=0.5)
       v    := [-1.38,0.40,1.2];
       batAngle := [0.9471,0.2,-0.4];
        
       else
        if(dot(ballp,[1,0,0])>0.5&& dot(ballp,[1,0,0])<=1)
       v        := [-1.38,0.40,1.2];
        batAngle := [0.9471,0.2,-0.3];
        else
         if(dot(ballp,[1,0,0])>1)
       v        := [-1.38,0.40,1.2];
       batAngle := [0.9471,0.2,-0.2];
       end;
       end;
       end;
       end;


    if(dot(ballp,[0,1,0])>0.35&& dot(ballp,[0,1,0])<=0.6)
      if(dot(ballp,[1,0,0])>0&& dot(ballp,[1,0,0])<=0.5)
       v    := [-1.38,0.40,1.2];
       batAngle := [0.9471,0.3,-0.4];
        
       else
        if(dot(ballp,[1,0,0])>0.5&& dot(ballp,[1,0,0])<=1)
       v        := [-1.38,0.40,1.2];
        batAngle := [0.9471,0.3,-0.3];
        else
         if(dot(ballp,[1,0,0])>1)
       v        := [-1.38,0.40,1.2];
       batAngle := [0.9471,0.3,-0.2];
       end;
       end;
       end;
       end;
    if(dot(ballp,[0,1,0])>0.6)
      if(dot(ballp,[1,0,0])>0&& dot(ballp,[1,0,0])<=0.5)
       v    := [-1.38,0.40,1.2];
       batAngle := [0.9471,0.4,-0.4];
        
       else
        if(dot(ballp,[1,0,0])>0.5&& dot(ballp,[1,0,0])<=1)
       v        := [-1.38,0.40,1.2];
        batAngle := [0.9471,0.4,-0.3];
        else
         if(dot(ballp,[1,0,0])>1)
       v        := [-1.38,0.40,1.2];
       batAngle := [0.9471,0.4,-0.2];
       end;
       end;
       end;
       end;




if(dot(ballp,[0,1,0])<-0.1&& dot(ballp,[0,1,0])>=-0.35)
      if(dot(ballp,[1,0,0])>0&& dot(ballp,[1,0,0])<=0.5)
       v        := [-1.7,-0.2,3.86];
     batAngle := [0.96,-0.2,-0.4];        
       else
        if(dot(ballp,[1,0,0])>0.5&& dot(ballp,[1,0,0])<=1)
       v        := [-1.7,-0.2,3.86];
     batAngle := [0.96,-0.2,-0.3];
else
         if(dot(ballp,[1,0,0])>1)
       v        := [-1.7,-0.2,3.86];
     batAngle := [0.96,-0.2,-0.2];
       end;
       end;
       end;
       end;
if(dot(ballp,[0,1,0])<-0.35&&dot(ballp,[0,1,0])>-0.6)
      if(dot(ballp,[1,0,0])>0&& dot(ballp,[1,0,0])<=0.5)
       v        := [-1.7,-0.2,3.86];
     batAngle := [0.96,-0.3,-0.4];        
       else
        if(dot(ballp,[1,0,0])>0.5&& dot(ballp,[1,0,0])<=1)
       v        := [-1.7,-0.2,3.86];
     batAngle := [0.96,-0.3,-0.3];
else
         if(dot(ballp,[1,0,0])>1)
       v        := [-1.7,-0.2,3.86];
     batAngle := [0.96,-0.3,-0.2];
       end;
       end;
       end;
       end;
if(dot(ballp,[0,1,0])<-0.6)
      if(dot(ballp,[1,0,0])>0&& dot(ballp,[1,0,0])<=0.5)
       v        := [-1.7,-0.2,3.86];
     batAngle := [0.96,-0.4,-0.4];        
       else
        if(dot(ballp,[1,0,0])>0.5&& dot(ballp,[1,0,0])<=1)
       v        := [-1.7,-0.2,3.86];
     batAngle := [0.96,-0.4,-0.3];
else
         if(dot(ballp,[1,0,0])>1)
       v        := [-0.7,-0.2,3.86];
     batAngle := [0.96,-0.4,-0.2];
       end;
       end;
       end;
       end;


if(dot(ballp,[0,1,0])<=0.1&& dot(ballp,[0,1,0])>=-0.1)
      if(dot(ballp,[1,0,0])>0&& dot(ballp,[1,0,0])<=0.5)
       v    := [-1.38,0.40,1.2];
       batAngle := [0.9471,0,-0.4];
        
       else
        if(dot(ballp,[1,0,0])>0.5&& dot(ballp,[1,0,0])<=1)
       v        := [-1.38,0.40,1.2];
        batAngle := [0.9471,0,-0.3];
        else
         if(dot(ballp,[1,0,0])>1)
            v        := [-1.38,0.40,1.2];
       batAngle := [0.9471,0,-0.2];
       end;
       end;
       end;
       end;
end;


else
  if(dot(ballv,[0,1,0]) < 0)
    v        := [0.1,-0.15,3.85];
    batAngle := [-0.938,-0.162,-0.29];
   else
    v        := [1,0,2.85];
    batAngle := [-0.938,0.202,-0.29];
    end;
end;


  serve  := false;
  hit    := true;
  mode   := "Wait";
 case "Panic!"
 end
end


class PingPing(n)
 private
  mode      := "Wait";
  bounced   := false;       // Tell whether the ball bounced or not
  serve := false;           // The Game class will set serve flag to true
  hit   := false;           // when it's your turn
  count := 0;
  scount := 0;
  ballv := [0,0,0];
  ballp := [0,0,0];
  batp  := [1.6,0,0.2];
  v     := [0,0,0];         // Bat's speed
  batAngle   := [0,0,0.1];  // Normal vector of the bat's plane
  batAngle'  := [0,0,0];
  // Player(1) starts at [-1.6,0,0.2], Player(2) starts at [1.6,0,0.2]
  startPoint := [1.6*(-1)^n,0,0.2];
  t   := 0;
  t'  := 1;
 end
 if mode <> "Wait"&& mode <> "Prepare"&& mode <> "Hit"
   mode := "Panic!";
 end;
 t'  = 1;
 switch mode
  case "Wait"               // While waiting, moving the bat to starting point
   count      := 0;
   if n == 2
        if(batp == startPoint)
                scount := 0;
        end;
     v         = [0,0,0]
     //v         = startPoint-batp;
   else
     v         = [0,0,0]
     //v         = startPoint-batp;
   end;
   batAngle' = [0,0,0]-batAngle;
   hit    := false;
   if serve == true
    mode    := "Prepare";
    bounced := false;
   else
    mode := "Wait";
   end;
  case "Prepare"             // Prepare to hit the ball
   if bounced == true        // After the ball has bounced,
                             // start moving the bat towards the ball
     v = (ballp-batp).*[0,20,0] + (ballp-batp).*[0,0,25] +
            (ballp+[0.12*(-1)^n,0,0]-batp).*[25,0,0];
     if norm(batp - ballp)<0.15&& abs(dot(ballp,[1,0,0])) >=
                                abs(dot(startPoint,[1,0,0]))
      count := count+1;
      mode  := "Hit";
     end;
   end;
   // When the ball has bounced and it is at the highest position
   if count > 0&& dot(ballv,[0,0,1]) < 0.1&& bounced == true
            mode := "Hit";     // This player decide to hit.
   end;
   if dot(ballp,[0,0,1]) < 0&& bounced == false
    bounced := true;
   end;
   if(serve <> true)
     mode := "Wait";
   end;
 case "Hit"           // Decide how you want hit the ball,
   if n == 2
     if(serve == true&& scount == 0)
        if(dot(ballp,[0,1,0]) > 0)
          v        := [-1,0.2,1.2];
            batAngle := [dot(ballp,[1,0,0])+1.3,dot(ballp,[0,1,0])+0.7,-0.2]/
          norm([dot(ballp,[1,0,0])+1.3,dot(ballp,[0,1,0])+0.7,-0.2]);        
        else
          v        := [-1,0.2,1.2];
            batAngle := [dot(ballp,[1,0,0])+1.3,dot(ballp,[0,1,0])-0.7,-0.2]/
          norm([dot(ballp,[1,0,0])+1.3,dot(ballp,[0,1,0])+0.7,-0.2]);
        end;        
        if(dot(ballp,[0,1,0]) <= 0.2&& dot(ballp,[0,1,0]) >= -0.2)
          v        := [-1,0,1.2];
            batAngle := [0.95,0,-0.2];
        end;
            scount := 1;
     else
        if(dot(ballp,[0,1,0]) > 0)        //Right of P2
          v        := [-1,0.2,1.2];
          batAngle := [dot(ballp,[1,0,0])+1.3,dot(ballp,[0,1,0])+0.7,-0.2]/
          norm([dot(ballp,[1,0,0])+1.3,dot(ballp,[0,1,0])+0.7,-0.2]);        
        else                                //Left of P2
          v        := [-1,0.2,1.2];
          batAngle := [dot(ballp,[1,0,0])+1.3,dot(ballp,[0,1,0])-0.7,-0.2]/
          norm([dot(ballp,[1,0,0])+1.3,dot(ballp,[0,1,0])+0.7,-0.2]);        
        end;
    end;
  else


      if(dot(ballv,[0,1,0]) < 0)        //Right of P1
        if( dot(ballp,[0,1,0]) > -0.4)
                    v        := [0.1,-0.15,3.85];
                    batAngle := [-0.938,-0.162,-0.29];
        else
                v        := [0.1,-0.15,3.85];
                    batAngle := [-0.938,-0.362,-0.29];
        end;
      else                                //Left of P1
           if(dot(ballv,[0,1,0]) > 0.4)
                    v        := [1,0,2.85];
                    batAngle := [-0.938,0.4,-0.29];
           else
                v        := [1,0,2.85];
                    batAngle := [-0.938,0.202,-0.29];
           end;
      end;
  end;
  serve  := false;
  hit    := true;
  mode   := "Wait";
 case "Panic!"
 end
end






class WiffWaff(n)
 private
  mode      := "Wait";
  bounced   := false;       // Tell whether the ball bounced or not
  serve := false;           // The Game class will set serve flag to true
  hit   := false;           // when it's your turn
  count := 0;
  ballv := [0,0,0];
  ballp := [0,0,0];
  batp  := [1.6,0,0.2];
  v     := [0,0,0];         // Bat's speed
  batAngle   := [0,0,0.1];  // Normal vector of the bat's plane
  batAngle'  := [0,0,0];
  // Player(1) starts at [-1.6,0,0.2], Player(2) starts at [1.6,0,0.2]
  startPoint := [1.6*(-1)^n,0,0.2];
  v2         := [0,0,0];    // The output speed of the ball, which we desired
  v21        := [0,0,0];
  z   := 0;
  n1   := 0;
  t   := 0;
  t'  := 1;
  number := n;
 end
 number = n;
 startPoint = [1.6*(-1)^number,0,0.2];
 if mode <> "Wait"&& mode <> "Prepare"&& mode <> "Hit"
   mode := "Panic!";
 end;
 t'  = 1;
 switch mode
  case "Wait"               // While waiting, moving the bat to starting point
   count      := 0;
   if n == 1
     v         = startPoint-batp;
   else
     v         = startPoint-batp;
   end;
   batAngle' = [0,0,0]-batAngle;
   hit    := false;
   if serve == true
    mode    := "Prepare";
    bounced := false;
   else
    mode := "Wait";
   end;
  case "Prepare"             // Prepare to hit the ball
   if bounced == true        // After the ball has bounced,
                             // start moving the bat towards the ball
     v = (ballp-batp).*[0,20,0] + (ballp-batp).*[0,0,25] +
                   (ballp+[0.12*(-1)^n,0,0]-batp).*[25,0,0];
     if norm(batp - ballp)<0.15&& abs(dot(ballp,[1,0,0])) >=
                                      0.8* abs(dot(startPoint,[1,0,0]))
      count := count+1;
      mode  := "Hit";
     end;
   end;
   // When the ball has bounced and it is at the highest position
   if count > 0&& dot(ballv,[0,0,1]) < 0.1&& bounced == true
    mode := "Hit";     // This player decide to hit.
   end;
   if dot(ballp,[0,0,1]) < 0&& bounced == false
    bounced := true;
   end;
   if(serve <> true)
     mode := "Wait";
   end;
 case "Hit"           // Decide how you want hit the ball,
  if n == 2
    v2  := [-(dot(ballp, [1,0,0] ) + 0.75 + 0.5 ), -dot( ballp, [0,1,0]
), 5 - dot(ballp,[0,0,1])];
        v21 := (v2 - ballv) / (-2) ;
        n1   :=  norm(v21);
        batAngle := v21 / n1;
        z := (n1- dot(batAngle, [1,0,0])*4) / dot(batAngle, [0,0,1]);
        v := ballv - [4,0,z];
        //v        := [-0.5,0.71,1.37];
    //batAngle := [0.87,0.14,-0.47];
  else
    v2  := [(-dot(ballp, [1,0,0] ) + 0.75 + 0.5 ), -dot( ballp, [0,1,0]
), 5 - dot(ballp,[0,0,1])];
        v21 := (v2 - ballv) / (-2) ;
        n1   :=  norm(v21);
        batAngle := v21 / n1;
        z := (n1- dot(batAngle, [1,0,0])*4) / dot(batAngle, [0,0,1]);
        v := ballv - [4,0,z];
   end;
  serve  := false;
  hit    := true;
  mode   := "Wait";
 case "Panic!"
 end
end


class ParadoX(n)
private
  mode      := "Wait";
  bounced   := false;       // Tell whether the ball bounced or not
  serve := false;           // The Game class will set serve flag to true
  hit   := false;           // when it's your turn
  count := 0;
  ballv := [0,0,0];
  ballp := [0,0,0];
  batp  := [1.6,0,0.2];
  v     := [0,0,0];         // Bat's speed
  batAngle   := [0,0,0.1];  // Normal vector of the bat's plane
  batAngle'  := [0,0,0];
  // Player(1) starts at [-1.6,0,0.2], Player(2) starts at [1.6,0,0.2]
  startPoint := [1.6*(-1)^n,0,0.2];
  t   := 0;
  t'  := 1;
 end
 if mode <> "Wait"&& mode <> "Prepare"&& mode <> "Hit"
   mode := "Panic!";
 end;
 t'  = 1;
 switch mode
  case "Wait"               // While waiting, moving the bat to starting point
   count      := 0;
   if n == 1
     v         = startPoint-batp;
   else
     v         = startPoint + [0,0.75,0] - batp;
   end;
   batAngle' = [0,0,0]-batAngle;
   hit    := false;
   if serve == true
    mode    := "Prepare";
    bounced := false;
   else
    mode := "Wait";
   end;
  case "Prepare"             // Prepare to hit the ball
   if bounced == true        // After the ball has bounced,
                             // start moving the bat towards the ball
     v = (ballp-batp).*[0,20,0] + (ballp-batp).*[0,0,25] +
            (ballp+[0.12*(-1)^n,0,0]-batp).*[25,0,0];
     if norm(batp - ballp)<0.15&& abs(dot(ballp,[1,0,0])) >=
                                abs(dot(startPoint,[1,0,0]))
      mode  := "Hit";
     end;
   end;
   // When the ball has bounced and it is at the highest position
   if count > 0&& dot(ballv,[0,0,1]) < 0.1&& dot(ballp,[0,0,1]) >
0.1&& bounced == true
    mode := "Hit";     // This player decide to hit.
   end;
   if dot(ballp,[0,0,1]) < 0&& bounced == false
    bounced := true;
count := 1;
   end;
   if(serve <> true)
     mode := "Wait";
   end;
 case "Hit"           // Decide how you want hit the ball,
          if n == 2
                            v        := [-0.1,-0.15,3.85];
                           batAngle := [0.938,0.162,-0.29];
  else
   if(dot(ballv,[0,1,0]) < 0)
    v        := [0.1,-0.15,3.85];
    batAngle := [-0.938,-0.162,-0.29];
   else
    v        := [1,0,2.85];
    batAngle := [-0.938,0.202,-0.29];
    end;
   end;
  serve  := false;
  hit    := true;
  mode   := "Wait";
 case "Panic!"
 end
end


class XPTO(n)
 private
  mode          := "Wait";
  bounced   := false;           // Tell whether the ball bounced or not
  serve := false;               // The Game class will set serve flag to true
  hit   := false;               // when it's your turn
  count := 0;
  ballv := [0,0,0];
  ballp := [0,0,0];
  batp  := [1.6,0,0.2];
  v         := [0,0,0];             // Bat's speed
  batAngle   := [0,0,0.1];  // Normal vector of the bat's plane
  batAngle'  := [0,0,0];
  // Player(1) starts at [-1.6,0,0.2], Player(2) starts at [1.6,0,0.2]
  startPoint := [1.6,0,0.2];
  t   := 0;
  t'  := 1;
 end
 if mode <> "Wait"&& mode <> "Prepare"&& mode <> "Hit"
   mode := "Panic!";
 end;
 t'  = 1;
 switch mode
  case "Wait"                   // While waiting, moving the bat to starting point
   count          := 0;
   v             = startPoint- batp;
   batAngle' = [0,0,0]-batAngle;
   hit        := false;
   if serve == true
        mode        := "Prepare";
        bounced := false;
   else
        mode := "Wait";
   end;
  case "Prepare"                 // Prepare to hit the ball
   if bounced == true            // After the ball has bounced,
                                 // start moving the bat towards the ball
         v = (ballp-batp).*[0,20,0] + (ballp-batp).*[0,0,25] +
               (ballp+[0.12*(-1)^2,0,0]-batp).*[25,0,0];
         if norm(batp - ballp)<0.15&& abs(dot(ballp,[1,0,0])) >=
                                   abs(dot(startPoint,[1,0,0]))
          count := count+1;
          mode  := "Hit";
         end;
   end;
   // When the ball has bounced and it is at the highest position
   if count > 0&& dot(ballv,[0,0,1]) < 0.1&& bounced == true
        mode := "Hit";         // This player decide to hit.
   end;
   if dot(ballp,[0,0,1]) < 0&& bounced == false
        bounced := true;
   end;
   if(serve <> true)
         mode := "Wait";
   end;
 case "Hit"               // Decide how you want hit the ball,
         if(t<1||t>5)           // you may want to check the formulas
                          // in the BallActuator() class
           v            := [-1, 0.40, 1.2];
           batAngle := [0.92, 0, -0.1];
         else
           if t > 4&& t < 5
             v            := [-0.88, -0.2, 0.2];
             batAngle := [0.92, 0.05, -0.1];
           else
             v            := [-0.7, -0.2, 3.76];
             batAngle := [0.96, 0.1, -0.2258];
           end;
         end;


  serve  := false;
  hit        := true;
  mode   := "Wait";
 case "Panic!"
 end
end


class Virtue(n)
 private
  mode      := "Wait";
  bounced   := false;       // Tell whether the ball bounced or not
  serve := false;           // The Game class will set serve flag to true
  hit   := false;           // when it's your turn
  count := 0;
  ballv := [0,0,0];
  ballp := [0,0,0];
  batp  := [1.6,0,0.2];
  v     := [0,0,0];         // Bat's speed
  batAngle   := [0,0,0.1];  // Normal vector of the bat's plane
  batAngle'  := [0,0,0];
  // Player(1) starts at [-1.6,0,0.2], Player(2) starts at [1.6,0,0.2]
  startPoint := [1.6*(-1)^n,0,0.2];
  t   := 0;
  t'  := 1;
 end
 if mode <> "Wait"&& mode <> "Prepare"&& mode <> "Hit"
   mode := "Panic!";
 end;
 t'  = 1;
 switch mode
  case "Wait"               // While waiting, moving the bat to starting point
   count      := 0;
   if n == 1
     v         = startPoint-batp;
   else
     v         = startPoint + [0,0.75,0] - batp;
   end;
   batAngle' = [0,0,0]-batAngle;
   hit    := false;
   if serve == true
    mode    := "Prepare";
    bounced := false;
   else
    mode := "Wait";
   end;
  case "Prepare"             // Prepare to hit the ball
   if bounced == true        // After the ball has bounced,
                             // start moving the bat towards the ball
     v = (ballp-batp).*[0,20,0] + (ballp-batp).*[0,0,25] +
           (ballp+[0.12*(-1)^n,0,0]-batp).*[25,0,0];
     if norm(batp - ballp)<0.15&& abs(dot(ballp,[1,0,0])) >=
                               abs(dot(startPoint,[1,0,0]))
      count := count+1;
      mode  := "Hit";
     end;
   end;
   // When the ball has bounced and it is at the highest position
   if count > 0&& dot(ballv,[0,0,1]) > -0.6&& bounced == true  //vvv <0.5 -> >-0.6 hit earlier
    mode := "Hit";     // This player decide to hit.
   end;
   if dot(ballp,[0,0,1]) < 0&& bounced == false
    bounced := true;
   end;
   if(serve <> true)
     mode := "Wait";
   end;
 case "Hit"           // Decide how you want hit the ball,
  if n == 2
   if(t<1||t>5)       // you may want to check the formulas
                      // in the BallActuator() class
    v        := [-0.38,0.40,1.2];   // vvv -1.38 -> -0.38 less acc in x dir
    batAngle := [0.9471,0.25,-0.7]; // vvv -0.2->-0.7 big parable
   else
    if t > 4&& t < 5
     v        := [-0.88,-0.5,0.2];
     batAngle := [0.9471,0.25,-0.2];
    else
     v        := [-1.7,-0.2,3.86];
     batAngle := [0.96,-0.1,-0.2258];
    end;
   end;
  else
   v        := [0.6,4.45,0.95]; // vvv 0.2->0.6, 3.85->4.45, 0.85->0.95big parable
   batAngle := [-0.938,-0.162,-0.29];
  end;
  serve  := false;
  hit    := true;
  mode   := "Wait";
 case "Panic!"
 end
end


class Table()   // The table (a static 3D object)
 private
        // Board
 _3D := [["Box", [0,0,-0.05],[3,1.5,0.03],[0.1,0.1,1.0],[0,0,0]],
        // TableBases 1~4
        ["Box", [-1.4,0.6,-0.3-0.04], [0.05,0.05,0.6],
                [0.8,0.8,0.8],[0,0,0]],
        ["Box", [-1.4,-0.6,-0.3-0.04], [0.05,0.05,0.6],
                [0.8,0.8,0.8],[0,0,0]],
        ["Box", [1.4,-0.6,-0.3-0.04], [0.05,0.05,0.6], 
                [0.8,0.8,0.8],[0,0,0]],
        ["Box", [1.4,0.6,-0.3-0.04], [0.05,0.05,0.6], 
                [0.8,0.8,0.8],[0,0,0]],
        // Net
        ["Box", [0,0,0.125-0.02], [0.05,1.5,0.25],
                [0.2,0.8,0.2],[0,0,0]],
        // MiddleLine
        ["Box", [0,0,0],[3,0.02,0.02-0.02],[1,1,1],[0,0,0]]]
 end
end


class BallActuator()  // Drives ball (and models impacts)
  private
   mode := "Initialize";
   v1 := [0,0,0];      // Ball speed (set by Parent)
   v2 := [0,0,0];      // Ball speed as set by actuator
   v3 := [0,0,0];      // Bat's speed (set by Parent)
   angle := [0,0,0];   // Bat's normal vector (set by Parent)
   done  := false;     // When collision is completed
   action := 0;        // Trigger for actuation (set by Parent)
 end
  if mode <> "Initialize"&& mode <> "Calculate"&& mode <> "Wait"
   mode := "Panic!";
  end;
 switch mode
  case "Initialize"
   done = false;
   if action == 1
    mode := "Calculate";
   end;
 case "Calculate" // Compute impact reset equation
  v2     := v1-dot(2.*(v1-v3),angle)*angle;
  action := 0;     // Reset action to 0
  if action == 0
   mode := "Wait";
  end;
 case "Wait"
  done = true;
 case "Panic!"
 end
end


// Models player’s imperfect ability to observe ball
class BallObserver()
 private
  mode := "Sample";
  p  := [0,0,0];  // Ball position (set by Parent)
  v  := [0,0,0];  // Ball velocity (estimated here)
  pp := [0,0,0];
  ap := [0,0,0];
  t  := 0;
  t' := 1;
 end
 t'=1;
 if mode <> "Sample"&& mode <> "Estimate0"&& mode <> "Estimate1"
  mode := "Panic!";
 end;
 switch mode
   case "Sample"
    if t > 0
     pp  := p;
     t   := 0;
     mode:= "Estimate0"
    end;
   case "Estimate0"
 if t == 0.01   // Estimating average speed
     ap   := p;
     mode := "Estimate1";
    end;
   case "Estimate1"
    v    := dot((ap-pp),[1,0,0])/0.01*[1,0,0]+dot((ap-pp),
               [0,0,1])/0.01*[0,0,1]+
               dot((ap-pp),[0,1,0])/0.01*[0,1,0];
    mode := "Sample";
    t    := 0;
   case "Panic!"
  end
end


class Referee()  // This class will monitors the whole game.
 private
  mode:="Initialize";
  x := 0; x' := 0;
  z := 0; z' := 0;
  y := 0;
  t := 0; t' := 1;
  player1Score := 0;
  player2Score := 0;
  serveNumber  := 2;
  lastHit      := 0;
  reason       := "Nothing";
  checked      := false;    // For the net checking
  bounced      := false;
  restart      := 0;        // Tell the Game to restart
  acknowledged := 0;        // Check if the Game class has received
                           //  the restart signal
  bounceTime   := 0;
  status       := "Normal"
 end
 if mode <> "Initialize"&& mode <> "Player1Lost"&& mode <> "Player2Lost"
  && mode <> "SendMessage"&& status <> "Normal"&& reason <> "Nothing"
  && status <> "Report"&& reason <> "BallOutOfBoundary"
&& reason <> "BallBouncedTwice"&& reason <> "BallTouchNet"
  mode := "Panic!";
 end;
  t'=1;
  if z<0.05&& z'<0&& status == "Normal"  // Check if anyone fouls
   if (abs(y)>0.78||abs(x)>1.53)&& status == "Normal"
    reason     := "BallOutOfBoundary";
    if bounced == false
     if x>0
      mode := "Player1Lost";
     else
      mode := "Player2Lost";
     end;
    else
     if bounced == "YesIn2"    // The ball has bounced in player2's court,
      mode := "Player2Lost"     // and out of boundary now, so player2 lose.
     end;
     if bounced == "YesIn1"
      mode := "Player1Lost";
     end;
    end;
    status := "Report";
   end;
   if(abs(y)<0.78&& abs(x)<1.53)&& bounced <> false
    && t>(bounceTime+0.1)&& status=="Normal"
 // The ball has bounced twice in player2's court
    if bounced == "YesIn2"&& x > 0
     mode   := "Player2Lost";
     reason := "BallBouncedTwice";
  bounceTime := t;
    end;
 // The ball has bounced twice in player1's court
    if bounced == "YesIn1"&& x < 0
     mode   := "Player1Lost";
     reason := "BallBouncedTwice";
  bounceTime := t;
    end;
   end;
   if x<0&& x>-1.5&& bounced == false&& status == "Normal"
    bounced    := "YesIn1";
    bounceTime := t;
   end;
   if x>=0&& x<1.5&& bounced == false&& status == "Normal"
    bounced    := "YesIn2";
    bounceTime := t;
   end;
 end;


 if bounced == "YesIn1"&& x>0&& status == "Normal"
  bounced := false
 end;
 if bounced == "YesIn2"&& x<=0&& status == "Normal"
  bounced := false
 end;
  // Time to check if the ball touches the net
 if abs(x)<0.025&& t>0.1&& checked == false&& status == "Normal"
  if z<0.25
    if x'>0
     mode   := "Player1Lost";
    else
     mode   := "Player2Lost"
    end;
    reason  := "BallTouchNet";
    checked := true;
  end;
 end;
switch mode
 case "Initialize"
 case "Player1Lost"
  player2Score := player2Score+1;
  mode := "SendMessage";
 case "Player2Lost"
  player1Score := player1Score+1;
  mode := "SendMessage";
 case "SendMessage"
  t := 0; // Wait until the Game class gets the restart signal
  restart := 1;
  if acknowledged == 1
    mode := "Initialize";
    acknowledged := 0;
    restart := 0;
    status  := "Normal";
    checked := false;
    bounced := false;
  end;
  case "Panic!"
 end
end


/**
* The parent of all the other classes, who controls the
* whole process of the game.
**/
class Game ()
 private
  player1 := create Terminator (1); // First Player;
  player2 := create Terminator (2); // Second Player;
  ball    := create Ball ();
  ballob  := create BallObserver();
  actuator:= create BallActuator();
  batActuator1 := create BatActuator([-1.6,0,0.2]);
  batActuator2 := create BatActuator([1.6,0,0.2]);
  bat1    := create Bat(1,[-1.6,0,0.2]);
  bat2    := create Bat(2,[1.6,0,0.2]);
  table   := create Table();
  gameMonitor := create Referee();
  mode    := "Player2Serve";       // Player2 starts first
  player2Score := 0;
  player1Score := 0;
  serveNumber  := 2;
  t  := 0;
  t' := 1;
  maxEnergy    := 18;
 end
  if mode <> "Restart"    && mode <> "Player1Serve"&& 
     mode <> "Player2Serve"&& mode <> "Impact"     && 
     mode <> "Freeze"     && mode <> "ChangeSide" && 
     mode <> "Act"
   mode := "Panic!"
  end;
  t'=1;
  gameMonitor.x  = dot(ball.p,[1,0,0]);
  gameMonitor.x' = dot(ball.p',[1,0,0]);
  gameMonitor.z  = dot(ball.p,[0,0,1]);
  gameMonitor.z' = dot(ball.p',[0,0,1]);
  gameMonitor.y  = dot(ball.p,[0,1,0]);
  gameMonitor.serveNumber = serveNumber;
  player1Score  = gameMonitor.player1Score;
  player2Score  = gameMonitor.player2Score;
  ballob.p          = ball.p;
  player1.ballp     = ballob.p;
  player2.ballp     = ballob.p;
  player1.ballv     = ballob.v;
  player2.ballv     = ballob.v;
  if bat1.mode <> "Rest"
   batActuator1.p' = player1.v;
  end;
  if bat2.mode <> "Rest"
   batActuator2.p' = player2.v;
  end;
  player1.batp  = bat1.p;
  player2.batp  = bat2.p;
  batActuator1.angle = player1.batAngle;
  batActuator2.angle = player2.batAngle;
  bat1.p  = batActuator1.p;
  bat1.p' = batActuator1.p';
  bat2.p  = batActuator2.p;
  bat2.p' = batActuator2.p';
  bat1.angle = batActuator1.angle;
  bat2.angle = batActuator2.angle;
  if batActuator1.energy > maxEnergy
     bat1.mode := "Rest";
     bat1.p'   := [0,0,0];
     batActuator1.p' = [0,0,0];
  end;
  if batActuator2.energy > maxEnergy
     bat2.mode := "Rest";
     bat2.p'   := [0,0,0];
     batActuator2.p' = [0,0,0];
  end;
 switch mode
  case "Restart" // Put everything back to the starting point
   ball.p            := [0,0,0.5];
   ball.p'           := [5,1,-3];
   bat2.p            := [1.6,0,0.2];
   player2.batp      := [1.6,0,0.2];
   player2.v         := [0,0,0];
   player2.batAngle  := [0.01,0,0];
   player2.bounced   := false;
   player2.ballp     := [1.6,0,0.2];
   bat1.p            := [-1.6,0,0.2];
   player1.batp      := [-1.6,0,0.2];
   player1.v         := [0,0,0];
   player1.batAngle  := [0.01,0,0];
   player1.bounced   := false;
   player1.ballp     := [-1.6,0,0.2];
   batActuator1.p    := [-1.6,0,0.2];
   batActuator2.p    := [1.6,0,0.2];
   serveNumber       := 2;
   gameMonitor.bounced      := false;
   gameMonitor.checked      := false;
   gameMonitor.acknowledged := 1;
   mode         := "Player2Serve";
   player1.mode := "Wait";
   player2.mode := "Wait";
  case "Player2Serve" // Player 2 is serving
   player1.serve = false;
   player2.serve =  true;
   if player2.hit == true&& norm(bat2.p - ball.p) < 0.15
    mode := "Impact"
   end;
   if gameMonitor.restart == 1
    mode := "Freeze";
    t    := 0;
   end;
 case "Player1Serve" // Player 1 is serving
  player2.serve = false;
  player1.serve = true;
  if player1.hit == true&& norm(bat1.p - ball.p) < 0.15
   mode := "Impact"
  end;
  if gameMonitor.restart == 1
   mode := "Freeze";
   t    := 0;
  end;
 case "Impact" // When one player hits the ball
  actuator.v1 := ball.p';
  if serveNumber == 2 // Give player2's data to actuator
   batActuator2.p' := player2.v;
   bat2.p'         := batActuator2.p';
   actuator.v3     := bat2.p';
   bat2.angle      := player2.batAngle;
   actuator.angle  := bat2.angle;
   actuator.action := 1; // Tell actuator to act
   gameMonitor.lastHit := 2;
   mode := "Act";
    if gameMonitor.restart == 1
      mode := "Freeze";
      t := 0;
    end;
  end;
  if serveNumber == 1 // Give player1's data to actuator
   batActuator1.p' := player1.v;
   bat1.p'         := batActuator1.p';
   actuator.v3     := bat1.p';
   bat1.angle      := player1.batAngle;
   actuator.angle  := bat1.angle;
   actuator.action := 1; // Tell actuator to act
   gameMonitor.lastHit := 1;
   mode := "Act";
   if gameMonitor.restart == 1
    mode := "Freeze";
    t    := 0;
   end;
  end
 case "Act" // Wait till actuator finish
  if gameMonitor.restart == 1
   mode := "Freeze";
   t    := 0;
  end;
  if actuator.done == true
   ball.p'       := actuator.v2;
   actuator.mode := "Initialize";
   mode          := "ChangeSide";
  end;
 case "ChangeSide" // Change the serve number
  if gameMonitor.restart == 1
   mode := "Freeze";
   t    := 0;
  end;
  if serveNumber == 2&& dot(ball.p,[1,0,0]) >0&& gameMonitor.restart <> 1
   serveNumber     := 1;
   mode            := "Player1Serve";
   player1.mode    := "Wait";
   player1.bounced := false;
  end;
  if serveNumber == 1&& dot(ball.p,[1,0,0]) <= 0&& gameMonitor.restart <> 1
   serveNumber     := 2;
   mode            := "Player2Serve";
   player2.mode    := "Wait";
   player2.bounced := false;
  end;
 // When someone fouls, showing what's going wrong for 1 second
 case "Freeze"
   if t<1
    ball.mode := "Freeze";
   else
    mode      := "Restart";
    ball.mode := "Fly";
   end;
 case "Panic!"
 end
end


class Main(simulator)
 private
  mode := "Initialize";
  score1 := 0;
  score2 := 0;
  game := 0;
  _3D := [["Text",[-2,0,-1],1,[0,0,1],[3.14/2,0,0],0],             
          ["Text",[1,0,-1],1,[0,0,1],[3.14/2,0,0],0]];
 end
switch mode
 case "Initialize"
  simulator.endTime := 40;
  game := create Game();
  mode := "Persist";
 case   "Persist"
  score1 = game.player1Score;
  score2 = game.player2Score;
  _3D = [["Text",[-2,0,-1],1,[1,0,0],[3.14/2,0,0],score1],
         ["Text",[1,0,-1],1,[0,0,1],[3.14/2,0,0],score2]];
 end
end
